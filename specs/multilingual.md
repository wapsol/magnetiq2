# Magnetiq v2 - Multilingual System Specification

## Overview

The multilingual system provides comprehensive internationalization (i18n) support for German and English languages across all components of Magnetiq v2, including content management, user interfaces, automated communications, and AI-powered translations.

## Language Requirements

### Supported Languages
- **English (en)**: Primary language and fallback
- **German (de)**: Secondary language with full feature parity

### Language Priorities
1. **English**: Default language, always available
2. **German**: Full translation coverage required
3. **Fallback Strategy**: English content when German unavailable
4. **Future Expansion**: Architecture supports additional languages

## Technical Architecture

### Data Storage Strategy

#### JSONB Multilingual Fields
```sql
-- PostgreSQL JSONB structure for multilingual content
CREATE TABLE pages (
    id UUID PRIMARY KEY,
    title JSONB NOT NULL, -- {"en": "About Us", "de": "Ãœber uns"}
    content JSONB,         -- {"en": "Content...", "de": "Inhalt..."}
    meta_description JSONB -- {"en": "Description", "de": "Beschreibung"}
);

-- Validation constraint
ALTER TABLE pages ADD CONSTRAINT valid_multilingual_title 
    CHECK (title ? 'en'); -- English is required
```

#### TypeScript Interface
```typescript
interface TranslatedText {
  en: string;
  de?: string;
}\n\ninterface MultilingualContent {
  [key: string]: TranslatedText;\n}\n\n// Usage example\ninterface Page {\n  id: string;\n  title: TranslatedText;\n  content: TranslatedText;\n  excerpt?: TranslatedText;\n}\n```

#### Database Indexing\n```sql\n-- GIN indexes for efficient multilingual searches\nCREATE INDEX idx_pages_title_en ON pages USING GIN ((title->>'en'));\nCREATE INDEX idx_pages_title_de ON pages USING GIN ((title->>'de'));\n\n-- Full-text search indexes\nCREATE INDEX idx_pages_search_en ON pages USING GIN (\n    to_tsvector('english', COALESCE(title->>'en', '') || ' ' || COALESCE(content->>'en', ''))\n);\n\nCREATE INDEX idx_pages_search_de ON pages USING GIN (\n    to_tsvector('german', COALESCE(title->>'de', '') || ' ' || COALESCE(content->>'de', ''))\n);\n```

### Frontend Implementation

#### React Context for Language Management\n```tsx\ninterface LanguageContextValue {\n  currentLanguage: 'en' | 'de';\n  setLanguage: (lang: 'en' | 'de') => void;\n  t: (key: string, params?: Record<string, any>) => string;\n  isLoading: boolean;\n  availableLanguages: Language[];\n}\n\nconst LanguageContext = createContext<LanguageContextValue | undefined>(undefined);\n\nexport const LanguageProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const [currentLanguage, setCurrentLanguage] = useState<'en' | 'de'>('en');\n  const [translations, setTranslations] = useState<Record<string, any>>({});\n  const [isLoading, setIsLoading] = useState(false);\n\n  useEffect(() => {\n    // Load translations for current language\n    loadTranslations(currentLanguage);\n  }, [currentLanguage]);\n\n  const setLanguage = useCallback((lang: 'en' | 'de') => {\n    setCurrentLanguage(lang);\n    // Persist language preference\n    localStorage.setItem('preferred-language', lang);\n    // Update document language\n    document.documentElement.lang = lang;\n  }, []);\n\n  const t = useCallback((key: string, params?: Record<string, any>) => {\n    const translation = getNestedTranslation(translations, key);\n    return interpolateParams(translation, params);\n  }, [translations]);\n\n  return (\n    <LanguageContext.Provider value={{\n      currentLanguage,\n      setLanguage,\n      t,\n      isLoading,\n      availableLanguages: [{ code: 'en', name: 'English' }, { code: 'de', name: 'Deutsch' }]\n    }}>\n      {children}\n    </LanguageContext.Provider>\n  );\n};\n```\n\n#### Translation Hook\n```tsx\nexport const useTranslation = () => {\n  const context = useContext(LanguageContext);\n  if (!context) {\n    throw new Error('useTranslation must be used within LanguageProvider');\n  }\n  return context;\n};\n\n// Helper hook for multilingual content\nexport const useMultilingualContent = () => {\n  const { currentLanguage } = useTranslation();\n  \n  const getContent = useCallback((content: TranslatedText | string): string => {\n    if (typeof content === 'string') return content;\n    return content[currentLanguage] || content.en || '';\n  }, [currentLanguage]);\n  \n  return { getContent, currentLanguage };\n};\n```\n\n#### Language Switcher Component\n```tsx\ninterface LanguageSwitcherProps {\n  style?: 'dropdown' | 'buttons' | 'flags';\n  position?: 'header' | 'footer' | 'sidebar';\n  showLabels?: boolean;\n}\n\nexport const LanguageSwitcher: React.FC<LanguageSwitcherProps> = ({\n  style = 'dropdown',\n  position = 'header',\n  showLabels = true\n}) => {\n  const { currentLanguage, setLanguage, availableLanguages } = useTranslation();\n  const [isOpen, setIsOpen] = useState(false);\n\n  const handleLanguageChange = (langCode: 'en' | 'de') => {\n    setLanguage(langCode);\n    setIsOpen(false);\n    \n    // Analytics tracking\n    analytics.track('language_changed', {\n      from: currentLanguage,\n      to: langCode,\n      position\n    });\n  };\n\n  if (style === 'buttons') {\n    return (\n      <div className=\"language-switcher-buttons\">\n        {availableLanguages.map(lang => (\n          <button\n            key={lang.code}\n            onClick={() => handleLanguageChange(lang.code as 'en' | 'de')}\n            className={`lang-button ${\n              currentLanguage === lang.code ? 'active' : ''\n            }`}\n            aria-label={`Switch to ${lang.name}`}\n          >\n            <span className={`flag flag-${lang.code}`} />\n            {showLabels && <span className=\"lang-label\">{lang.code.toUpperCase()}</span>}\n          </button>\n        ))}\n      </div>\n    );\n  }\n\n  // Dropdown implementation\n  return (\n    <div className=\"language-switcher-dropdown\">\n      <button\n        onClick={() => setIsOpen(!isOpen)}\n        className=\"lang-trigger\"\n        aria-label=\"Select language\"\n        aria-expanded={isOpen}\n      >\n        <span className={`flag flag-${currentLanguage}`} />\n        {showLabels && <span>{currentLanguage.toUpperCase()}</span>}\n        <ChevronDownIcon className={`chevron ${isOpen ? 'open' : ''}`} />\n      </button>\n      \n      {isOpen && (\n        <div className=\"lang-dropdown\">\n          {availableLanguages.map(lang => (\n            <button\n              key={lang.code}\n              onClick={() => handleLanguageChange(lang.code as 'en' | 'de')}\n              className={`lang-option ${\n                currentLanguage === lang.code ? 'selected' : ''\n              }`}\n            >\n              <span className={`flag flag-${lang.code}`} />\n              <span className=\"lang-name\">{lang.name}</span>\n              {currentLanguage === lang.code && <CheckIcon className=\"check\" />}\n            </button>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n};\n```\n\n### Backend Implementation\n\n#### Language Detection Middleware\n```python\nfrom fastapi import Request, Response\nimport re\n\nclass LanguageDetectionMiddleware:\n    def __init__(self, app, default_language: str = 'en'):\n        self.app = app\n        self.default_language = default_language\n        self.supported_languages = ['en', 'de']\n    \n    async def __call__(self, scope, receive, send):\n        if scope['type'] == 'http':\n            request = Request(scope, receive)\n            \n            # Language detection priority:\n            # 1. URL path parameter (/de/page)\n            # 2. Accept-Language header\n            # 3. User preference from session/cookie\n            # 4. Default language\n            \n            detected_language = self.detect_language(request)\n            scope['language'] = detected_language\n            \n            # Add language to request state\n            if not hasattr(request, 'state'):\n                request.state = type('State', (), {})() \n            request.state.language = detected_language\n            \n        await self.app(scope, receive, send)\n    \n    def detect_language(self, request: Request) -> str:\n        # Check URL path first\n        path_language = self.extract_language_from_path(request.url.path)\n        if path_language:\n            return path_language\n        \n        # Check Accept-Language header\n        accept_language = request.headers.get('Accept-Language', '')\n        header_language = self.parse_accept_language(accept_language)\n        if header_language:\n            return header_language\n        \n        # Check user preference cookie\n        cookie_language = request.cookies.get('language')\n        if cookie_language in self.supported_languages:\n            return cookie_language\n        \n        return self.default_language\n    \n    def extract_language_from_path(self, path: str) -> str | None:\n        \"\"\"Extract language from URL path like /de/page\"\"\"\n        match = re.match(r'^/([a-z]{2})/', path)\n        if match:\n            lang = match.group(1)\n            return lang if lang in self.supported_languages else None\n        return None\n    \n    def parse_accept_language(self, accept_language: str) -> str | None:\n        \"\"\"Parse Accept-Language header and return best match\"\"\"\n        languages = []\n        for lang_tag in accept_language.split(','):\n            parts = lang_tag.strip().split(';')\n            lang = parts[0].strip().lower()\n            quality = 1.0\n            \n            if len(parts) > 1 and parts[1].strip().startswith('q='):\n                try:\n                    quality = float(parts[1].strip()[2:])\n                except ValueError:\n                    pass\n            \n            # Extract primary language code\n            primary_lang = lang.split('-')[0]\n            if primary_lang in self.supported_languages:\n                languages.append((primary_lang, quality))\n        \n        # Return language with highest quality\n        if languages:\n            languages.sort(key=lambda x: x[1], reverse=True)\n            return languages[0][0]\n        \n        return None\n```\n\n#### Multilingual Content Service\n```python\nfrom typing import Dict, Optional, Any\nfrom sqlalchemy.orm import Session\nfrom models import Page, Translation\n\nclass MultilingualContentService:\n    def __init__(self, db: Session):\n        self.db = db\n    \n    async def get_content(\n        self, \n        content_id: str, \n        language: str = 'en'\n    ) -> Dict[str, Any]:\n        \"\"\"Get content with language fallback\"\"\"\n        page = self.db.query(Page).filter(Page.id == content_id).first()\n        if not page:\n            raise ContentNotFoundError(f\"Content {content_id} not found\")\n        \n        return {\n            'id': page.id,\n            'title': self.get_localized_text(page.title, language),\n            'content': self.get_localized_text(page.content, language),\n            'excerpt': self.get_localized_text(page.excerpt, language),\n            'language': language,\n            'available_languages': self.get_available_languages(page.title)\n        }\n    \n    def get_localized_text(\n        self, \n        multilingual_field: Dict[str, str], \n        language: str\n    ) -> str:\n        \"\"\"Get text in requested language with English fallback\"\"\"\n        if not multilingual_field:\n            return ''\n        \n        # Try requested language first\n        if language in multilingual_field and multilingual_field[language]:\n            return multilingual_field[language]\n        \n        # Fallback to English\n        return multilingual_field.get('en', '')\n    \n    def get_available_languages(self, multilingual_field: Dict[str, str]) -> List[str]:\n        \"\"\"Get list of available languages for content\"\"\"\n        if not multilingual_field:\n            return ['en']\n        \n        return [lang for lang, text in multilingual_field.items() if text and text.strip()]\n    \n    async def create_content(\n        self, \n        content_data: Dict[str, Any],\n        created_by: str\n    ) -> str:\n        \"\"\"Create multilingual content\"\"\"\n        # Validate that English content exists\n        for field in ['title', 'content']:\n            if field in content_data and isinstance(content_data[field], dict):\n                if 'en' not in content_data[field] or not content_data[field]['en']:\n                    raise ValidationError(f\"English {field} is required\")\n        \n        page = Page(\n            title=content_data.get('title', {}),\n            content=content_data.get('content', {}),\n            excerpt=content_data.get('excerpt', {}),\n            created_by=created_by\n        )\n        \n        self.db.add(page)\n        self.db.commit()\n        \n        return str(page.id)\n    \n    async def update_content(\n        self,\n        content_id: str,\n        updates: Dict[str, Any],\n        updated_by: str\n    ) -> bool:\n        \"\"\"Update multilingual content\"\"\"\n        page = self.db.query(Page).filter(Page.id == content_id).first()\n        if not page:\n            return False\n        \n        # Merge multilingual field updates\n        for field, value in updates.items():\n            if hasattr(page, field) and isinstance(value, dict):\n                current_value = getattr(page, field) or {}\n                # Merge languages, preserving existing translations\n                for lang, text in value.items():\n                    current_value[lang] = text\n                setattr(page, field, current_value)\n            elif hasattr(page, field):\n                setattr(page, field, value)\n        \n        page.updated_by = updated_by\n        self.db.commit()\n        \n        return True\n```\n\n## URL Structure & Routing\n\n### URL Patterns\n```\n# Language-neutral URLs (default to user's preferred language)\n/\n/about\n/services\n/webinars\n/whitepapers\n/book-consultation\n\n# Language-specific URLs\n/en/\n/en/about\n/en/services\n/de/\n/de/ueber-uns\n/de/leistungen\n\n# Admin panel (language-neutral, user preference)\n/admin\n/admin/webinars\n/admin/settings\n```\n\n### Frontend Routing Implementation\n```tsx\n// Route configuration with language support\nconst routes = [\n  {\n    path: '/:lang?',\n    element: <LanguageWrapper><HomePage /></LanguageWrapper>,\n    constraints: { lang: /^(en|de)?$/ }\n  },\n  {\n    path: '/:lang?/about',\n    element: <LanguageWrapper><AboutPage /></LanguageWrapper>\n  },\n  {\n    path: '/:lang?/webinars',\n    element: <LanguageWrapper><WebinarsPage /></LanguageWrapper>\n  },\n  {\n    path: '/:lang?/webinars/:slug',\n    element: <LanguageWrapper><WebinarDetailPage /></LanguageWrapper>\n  }\n];\n\n// Language wrapper component\nconst LanguageWrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const { lang } = useParams<{ lang?: string }>();\n  const { currentLanguage, setLanguage } = useTranslation();\n  const navigate = useNavigate();\n  const location = useLocation();\n  \n  useEffect(() => {\n    if (lang && lang !== currentLanguage) {\n      setLanguage(lang as 'en' | 'de');\n    } else if (!lang && location.pathname !== '/') {\n      // Redirect to language-specific URL\n      const newPath = `/${currentLanguage}${location.pathname}`;\n      navigate(newPath, { replace: true });\n    }\n  }, [lang, currentLanguage, location.pathname]);\n  \n  return <>{children}</>;\n};\n```\n\n### Backend Route Localization\n```python\nfrom fastapi import APIRouter, Depends, Request\nfrom services.multilingual import MultilingualContentService\nfrom dependencies import get_language, get_db\n\nrouter = APIRouter()\n\n@router.get('/api/v1/public/pages/{slug}')\nasync def get_page(\n    slug: str,\n    language: str = Depends(get_language),\n    db: Session = Depends(get_db)\n):\n    \"\"\"Get page content in requested language\"\"\"\n    content_service = MultilingualContentService(db)\n    \n    try:\n        page = await content_service.get_page_by_slug(slug, language)\n        return {\n            'success': True,\n            'data': page\n        }\n    except PageNotFoundError:\n        # Try alternative language slugs\n        alternative_page = await content_service.find_page_by_alternative_slug(\n            slug, language\n        )\n        if alternative_page:\n            return {\n                'success': True,\n                'data': alternative_page,\n                'redirected': True\n            }\n        \n        return {\n            'success': False,\n            'error': {'message': 'Page not found', 'code': 'PAGE_NOT_FOUND'}\n        }\n\ndef get_language(request: Request) -> str:\n    \"\"\"Extract language from request context\"\"\"\n    return getattr(request.state, 'language', 'en')\n```\n\n## Translation Management System\n\n### Translation Database Schema\n```sql\nCREATE TABLE translations (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    namespace VARCHAR(100) NOT NULL,\n    key VARCHAR(200) NOT NULL,\n    source_language VARCHAR(2) DEFAULT 'en',\n    target_language VARCHAR(2) NOT NULL,\n    source_text TEXT NOT NULL,\n    translated_text TEXT,\n    context TEXT,\n    status VARCHAR(20) DEFAULT 'pending',\n    translation_method VARCHAR(20) DEFAULT 'manual',\n    confidence_score DECIMAL(3,2),\n    translator_id UUID REFERENCES admin_users(id),\n    reviewer_id UUID REFERENCES admin_users(id),\n    translated_at TIMESTAMPTZ,\n    reviewed_at TIMESTAMPTZ,\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    updated_at TIMESTAMPTZ DEFAULT NOW(),\n    \n    UNIQUE(namespace, key, source_language, target_language),\n    \n    CONSTRAINT ck_translations_status \n        CHECK (status IN ('pending', 'translated', 'reviewed', 'approved', 'rejected')),\n    CONSTRAINT ck_translations_method \n        CHECK (translation_method IN ('manual', 'ai', 'imported')),\n    CONSTRAINT ck_translations_languages \n        CHECK (source_language IN ('en', 'de') AND target_language IN ('en', 'de'))\n);\n\nCREATE INDEX idx_translations_namespace_key ON translations(namespace, key);\nCREATE INDEX idx_translations_language ON translations(target_language);\nCREATE INDEX idx_translations_status ON translations(status);\n```\n\n### Admin Translation Interface\n```tsx\ninterface TranslationManager {\n  translationList: {\n    filters: {\n      namespace: string[];\n      status: TranslationStatus[];\n      language: ('en' | 'de')[];\n      method: TranslationMethod[];\n    };\n    \n    columns: [\n      'key',\n      'namespace', \n      'source_text',\n      'translated_text',\n      'status',\n      'method',\n      'translator',\n      'last_updated'\n    ];\n    \n    bulkActions: [\n      'approve',\n      'reject', \n      'assign_translator',\n      'generate_ai_translation',\n      'export_for_review'\n    ];\n  };\n  \n  translationEditor: {\n    sourceText: {\n      text: string;\n      context: string;\n      namespace: string;\n      key: string;\n    };\n    \n    targetText: {\n      editor: 'textarea' | 'rich_text';\n      aiSuggestions: boolean;\n      translationMemory: boolean;\n      spellCheck: boolean;\n    };\n    \n    qualityAssurance: {\n      lengthValidation: boolean;\n      formatValidation: boolean;\n      consistencyCheck: boolean;\n      contextWarnings: boolean;\n    };\n    \n    workflow: {\n      saveAsDraft: boolean;\n      submitForReview: boolean;\n      publishImmediately: boolean;\n      notifyReviewer: boolean;\n    };\n  };\n}\n```\n\n### AI Translation Integration\n```python\nfrom typing import Dict, List, Optional\nimport openai\nfrom services.translation_memory import TranslationMemoryService\n\nclass AITranslationService:\n    def __init__(self, api_key: str):\n        self.client = openai.OpenAI(api_key=api_key)\n        self.translation_memory = TranslationMemoryService()\n    \n    async def translate_text(\n        self,\n        text: str,\n        source_language: str,\n        target_language: str,\n        context: Optional[str] = None,\n        domain: str = 'general'\n    ) -> Dict[str, any]:\n        \"\"\"Translate text using AI with context awareness\"\"\"\n        \n        # Check translation memory first\n        memory_match = await self.translation_memory.find_match(\n            text, source_language, target_language\n        )\n        \n        if memory_match and memory_match['similarity'] > 0.95:\n            return {\n                'translated_text': memory_match['translation'],\n                'confidence': memory_match['similarity'],\n                'method': 'translation_memory',\n                'suggestion': True\n            }\n        \n        # Prepare context for AI translation\n        system_prompt = self.build_system_prompt(\n            source_language, target_language, domain, context\n        )\n        \n        user_prompt = f\"\"\"Translate the following {source_language} text to {target_language}:\n        \n        Text: {text}\n        \n        {f'Context: {context}' if context else ''}\n        \n        Requirements:\n        - Maintain the original meaning and tone\n        - Use appropriate business/technical terminology\n        - Keep formatting markers (HTML tags, placeholders) unchanged\n        - Adapt cultural references appropriately\n        \n        Translation:\"\"\"\n        \n        try:\n            response = await self.client.chat.completions.create(\n                model=\"gpt-4\",\n                messages=[\n                    {\"role\": \"system\", \"content\": system_prompt},\n                    {\"role\": \"user\", \"content\": user_prompt}\n                ],\n                temperature=0.1,  # Low temperature for consistency\n                max_tokens=2000\n            )\n            \n            translated_text = response.choices[0].message.content.strip()\n            \n            # Store in translation memory for future use\n            await self.translation_memory.store_translation(\n                source_text=text,\n                translated_text=translated_text,\n                source_language=source_language,\n                target_language=target_language,\n                context=context,\n                quality_score=0.8  # AI-generated baseline score\n            )\n            \n            return {\n                'translated_text': translated_text,\n                'confidence': 0.8,\n                'method': 'ai_translation',\n                'model': 'gpt-4',\n                'tokens_used': response.usage.total_tokens\n            }\n            \n        except Exception as e:\n            return {\n                'error': str(e),\n                'method': 'ai_translation',\n                'success': False\n            }\n    \n    def build_system_prompt(\n        self, \n        source_lang: str, \n        target_lang: str, \n        domain: str, \n        context: Optional[str]\n    ) -> str:\n        \"\"\"Build context-aware system prompt for AI translation\"\"\"\n        \n        lang_names = {'en': 'English', 'de': 'German'}\n        \n        prompt = f\"\"\"You are a professional translator specializing in {lang_names[source_lang]} to {lang_names[target_lang]} translation.\n        \n        Domain expertise: Business technology, AI/ML, digital transformation, consulting services.\n        \n        Key principles:\n        1. Accuracy: Preserve exact meaning and technical precision\n        2. Naturalness: Use native {lang_names[target_lang]} expressions and idioms\n        3. Consistency: Maintain consistent terminology throughout\n        4. Cultural adaptation: Adjust cultural references appropriately\n        5. Professional tone: Match the business/professional tone of the source\n        \n        Special considerations for German:\n        - Use appropriate formal/informal address (Sie/du)\n        - Follow German capitalization rules\n        - Use compound words appropriately\n        - Consider regional preferences (Germany, Austria, Switzerland)\n        \n        Always preserve:\n        - HTML tags and attributes\n        - Placeholder variables (e.g., {{name}}, {variable})\n        - URLs and email addresses\n        - Brand names and proper nouns\n        - Technical terms where established\n        \"\"\"\n        \n        if context:\n            prompt += f\"\\n\\nAdditional context for this translation: {context}\"\n        \n        return prompt\n    \n    async def batch_translate(\n        self,\n        texts: List[Dict[str, str]],\n        source_language: str,\n        target_language: str\n    ) -> List[Dict[str, any]]:\n        \"\"\"Translate multiple texts efficiently\"\"\"\n        results = []\n        \n        # Group similar texts for context-aware translation\n        grouped_texts = self.group_texts_by_context(texts)\n        \n        for group in grouped_texts:\n            group_results = []\n            \n            # Translate group with shared context\n            for text_item in group['texts']:\n                result = await self.translate_text(\n                    text_item['text'],\n                    source_language,\n                    target_language,\n                    context=group['context'],\n                    domain=group['domain']\n                )\n                result['id'] = text_item['id']\n                group_results.append(result)\n            \n            results.extend(group_results)\n        \n        return results\n```\n\n## SEO & URL Localization\n\n### Hreflang Implementation\n```tsx\n// SEO Head component with hreflang support\ninterface SEOHeadProps {\n  title: TranslatedText;\n  description: TranslatedText;\n  currentLanguage: 'en' | 'de';\n  alternateUrls: {\n    en: string;\n    de: string;\n  };\n  canonicalUrl: string;\n}\n\nexport const SEOHead: React.FC<SEOHeadProps> = ({\n  title,\n  description,\n  currentLanguage,\n  alternateUrls,\n  canonicalUrl\n}) => {\n  const { getContent } = useMultilingualContent();\n  \n  return (\n    <Helmet>\n      <html lang={currentLanguage} />\n      <title>{getContent(title)}</title>\n      <meta name=\"description\" content={getContent(description)} />\n      \n      {/* Canonical URL */}\n      <link rel=\"canonical\" href={canonicalUrl} />\n      \n      {/* Hreflang tags */}\n      <link rel=\"alternate\" hrefLang=\"en\" href={alternateUrls.en} />\n      <link rel=\"alternate\" hrefLang=\"de\" href={alternateUrls.de} />\n      <link rel=\"alternate\" hrefLang=\"x-default\" href={alternateUrls.en} />\n      \n      {/* Open Graph tags */}\n      <meta property=\"og:title\" content={getContent(title)} />\n      <meta property=\"og:description\" content={getContent(description)} />\n      <meta property=\"og:locale\" content={currentLanguage === 'de' ? 'de_DE' : 'en_US'} />\n      \n      {/* Alternate locales */}\n      {currentLanguage === 'en' && (\n        <meta property=\"og:locale:alternate\" content=\"de_DE\" />\n      )}\n      {currentLanguage === 'de' && (\n        <meta property=\"og:locale:alternate\" content=\"en_US\" />\n      )}\n      \n      {/* JSON-LD structured data */}\n      <script type=\"application/ld+json\">\n        {JSON.stringify({\n          \"@context\": \"https://schema.org\",\n          \"@type\": \"WebPage\",\n          \"name\": getContent(title),\n          \"description\": getContent(description),\n          \"inLanguage\": currentLanguage,\n          \"url\": canonicalUrl\n        })}\n      </script>\n    </Helmet>\n  );\n};\n```\n\n### Sitemap Generation\n```python\nfrom xml.etree.ElementTree import Element, SubElement, tostring\nfrom datetime import datetime\nfrom typing import List, Dict\n\nclass MultilingualSitemapGenerator:\n    def __init__(self, base_url: str):\n        self.base_url = base_url.rstrip('/')\n        self.supported_languages = ['en', 'de']\n    \n    async def generate_sitemap(self, pages: List[Dict]) -> str:\n        \"\"\"Generate multilingual sitemap with hreflang annotations\"\"\"\n        \n        urlset = Element('urlset')\n        urlset.set('xmlns', 'http://www.sitemaps.org/schemas/sitemap/0.9')\n        urlset.set('xmlns:xhtml', 'http://www.w3.org/1999/xhtml')\n        \n        for page in pages:\n            # Create URL entries for each language\n            for language in self.supported_languages:\n                if self.page_has_content(page, language):\n                    url = SubElement(urlset, 'url')\n                    \n                    # Localized URL\n                    loc_url = self.get_localized_url(page['slug'], language)\n                    SubElement(url, 'loc').text = loc_url\n                    \n                    # Last modified date\n                    if page.get('updated_at'):\n                        lastmod = page['updated_at'].strftime('%Y-%m-%d')\n                        SubElement(url, 'lastmod').text = lastmod\n                    \n                    # Change frequency and priority\n                    SubElement(url, 'changefreq').text = page.get('changefreq', 'monthly')\n                    SubElement(url, 'priority').text = str(page.get('priority', 0.5))\n                    \n                    # Hreflang alternate links\n                    for alt_lang in self.supported_languages:\n                        if self.page_has_content(page, alt_lang):\n                            alt_url = self.get_localized_url(page['slug'], alt_lang)\n                            link = SubElement(url, 'xhtml:link')\n                            link.set('rel', 'alternate')\n                            link.set('hreflang', alt_lang)\n                            link.set('href', alt_url)\n        \n        return '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n' + tostring(\n            urlset, encoding='unicode'\n        )\n    \n    def page_has_content(self, page: Dict, language: str) -> bool:\n        \"\"\"Check if page has content in specified language\"\"\"\n        title = page.get('title', {})\n        if isinstance(title, dict):\n            return language in title and bool(title[language])\n        return language == 'en'  # Fallback for non-multilingual content\n    \n    def get_localized_url(self, slug: str, language: str) -> str:\n        \"\"\"Generate localized URL for page\"\"\"\n        if language == 'en':\n            return f\"{self.base_url}/{slug}\"\n        else:\n            return f\"{self.base_url}/{language}/{slug}\"\n```\n\n## Email Localization\n\n### Email Template System\n```python\nfrom jinja2 import Environment, FileSystemLoader\nfrom typing import Dict, Any\n\nclass MultilingualEmailService:\n    def __init__(self, template_dir: str):\n        self.template_env = Environment(\n            loader=FileSystemLoader(template_dir),\n            extensions=['jinja2.ext.i18n']\n        )\n        self.supported_languages = ['en', 'de']\n    \n    async def send_multilingual_email(\n        self,\n        template_name: str,\n        recipient_email: str,\n        context: Dict[str, Any],\n        language: str = 'en'\n    ) -> bool:\n        \"\"\"Send email in specified language with fallback\"\"\"\n        \n        # Ensure language is supported\n        if language not in self.supported_languages:\n            language = 'en'\n        \n        try:\n            # Load language-specific template\n            template_path = f\"{template_name}_{language}.html\"\n            template = self.template_env.get_template(template_path)\n            \n            # Render email content\n            html_content = template.render(**context)\n            \n            # Get subject from template variables or context\n            subject = self.get_email_subject(\n                template_name, language, context\n            )\n            \n            # Send email\n            return await self.send_email(\n                to=recipient_email,\n                subject=subject,\n                html_content=html_content,\n                language=language\n            )\n            \n        except Exception as e:\n            # Fallback to English if language-specific template fails\n            if language != 'en':\n                return await self.send_multilingual_email(\n                    template_name, recipient_email, context, 'en'\n                )\n            raise e\n    \n    def get_email_subject(\n        self, \n        template_name: str, \n        language: str, \n        context: Dict[str, Any]\n    ) -> str:\n        \"\"\"Get localized email subject\"\"\"\n        subjects = {\n            'booking_confirmation': {\n                'en': 'Consultation Confirmed - {reference}',\n                'de': 'Beratungstermin bestÃ¤tigt - {reference}'\n            },\n            'webinar_registration': {\n                'en': 'Webinar Registration Confirmed - {webinar_title}',\n                'de': 'Webinar-Anmeldung bestÃ¤tigt - {webinar_title}'\n            },\n            'whitepaper_download': {\n                'en': 'Your Download: {whitepaper_title}',\n                'de': 'Ihr Download: {whitepaper_title}'\n            }\n        }\n        \n        subject_template = subjects.get(template_name, {}).get(\n            language, subjects.get(template_name, {}).get('en', 'Notification')\n        )\n        \n        return subject_template.format(**context)\n```\n\n### Email Template Structure\n```html\n<!-- templates/booking_confirmation_de.html -->\n<!DOCTYPE html>\n<html lang=\"de\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Beratungstermin bestÃ¤tigt</title>\n</head>\n<body>\n    <div class=\"email-container\">\n        <div class=\"header\">\n            <img src=\"{{ logo_url }}\" alt=\"voltAIc Systems\" class=\"logo\">\n            <h1>Ihr Beratungstermin ist bestÃ¤tigt</h1>\n        </div>\n        \n        <div class=\"content\">\n            <p>Liebe(r) {{ client_name }},</p>\n            \n            <p>vielen Dank fÃ¼r Ihre Buchung. Wir freuen uns auf unser GesprÃ¤ch!</p>\n            \n            <div class=\"booking-details\">\n                <h2>Termindetails</h2>\n                <table>\n                    <tr>\n                        <td><strong>Referenz:</strong></td>\n                        <td>{{ reference }}</td>\n                    </tr>\n                    <tr>\n                        <td><strong>Berater:</strong></td>\n                        <td>{{ consultant_name }}</td>\n                    </tr>\n                    <tr>\n                        <td><strong>Datum & Zeit:</strong></td>\n                        <td>{{ datetime | format_datetime('de') }}</td>\n                    </tr>\n                    <tr>\n                        <td><strong>Dauer:</strong></td>\n                        <td>{{ duration }} Minuten</td>\n                    </tr>\n                    <tr>\n                        <td><strong>Art:</strong></td>\n                        <td>{{ meeting_type | translate('de') }}</td>\n                    </tr>\n                </table>\n            </div>\n            \n            {% if meeting_url %}\n            <div class=\"meeting-access\">\n                <h2>Zugang zum Meeting</h2>\n                <p>Klicken Sie zum vereinbarten Zeitpunkt auf diesen Link:</p>\n                <a href=\"{{ meeting_url }}\" class=\"meeting-link\">Zum Meeting beitreten</a>\n            </div>\n            {% endif %}\n            \n            <div class=\"next-steps\">\n                <h2>NÃ¤chste Schritte</h2>\n                <ul>\n                    <li>Sie erhalten eine Kalendereinladung in separater E-Mail</li>\n                    <li>Bereiten Sie gerne Fragen zu Ihren Herausforderungen vor</li>\n                    <li>Bei Fragen kontaktieren Sie uns unter <a href=\"mailto:{{ support_email }}\">{{ support_email }}</a></li>\n                </ul>\n            </div>\n        </div>\n        \n        <div class=\"footer\">\n            <p>Mit freundlichen GrÃ¼ÃŸen,<br>\n            Ihr voltAIc Systems Team</p>\n            \n            <p class=\"contact-info\">\n                voltAIc Systems GmbH<br>\n                {{ company_address }}<br>\n                Tel: {{ company_phone }}<br>\n                E-Mail: <a href=\"mailto:{{ company_email }}\">{{ company_email }}</a>\n            </p>\n        </div>\n    </div>\n</body>\n</html>\n```\n\n## Quality Assurance & Testing\n\n### Multilingual Testing Framework\n```typescript\ninterface MultilingualTestSuite {\n  // Content Display Tests\n  testContentDisplay: {\n    testEnglishContentDisplay: () => void;\n    testGermanContentDisplay: () => void;\n    testFallbackToEnglish: () => void;\n    testMissingTranslations: () => void;\n  };\n  \n  // Language Switching Tests\n  testLanguageSwitching: {\n    testLanguageSwitcherDisplay: () => void;\n    testLanguagePreferencePersistence: () => void;\n    testUrlLanguageParameter: () => void;\n    testBrowserLanguageDetection: () => void;\n  };\n  \n  // SEO Tests\n  testSEOImplementation: {\n    testHreflangTags: () => void;\n    testLocalizedUrls: () => void;\n    testSitemapGeneration: () => void;\n    testCanonicalUrls: () => void;\n  };\n  \n  // Email Tests\n  testEmailLocalization: {\n    testGermanEmailTemplates: () => void;\n    testEnglishEmailTemplates: () => void;\n    testEmailSubjectLocalization: () => void;\n    testEmailFallback: () => void;\n  };\n  \n  // Form Tests\n  testFormLocalization: {\n    testFormValidationMessages: () => void;\n    testFormLabelTranslation: () => void;\n    testFormPlaceholderTranslation: () => void;\n  };\n  \n  // API Tests\n  testAPILocalization: {\n    testLanguageHeaderHandling: () => void;\n    testLocalizedErrorMessages: () => void;\n    testContentLanguageNegotiation: () => void;\n  };\n}\n```\n\n### Translation Quality Checks\n```python\nclass TranslationQualityChecker:\n    def __init__(self):\n        self.quality_rules = {\n            'length_variance': 0.5,  # Max 50% length difference\n            'placeholder_consistency': True,\n            'html_tag_consistency': True,\n            'capitalization_rules': True,\n            'punctuation_consistency': True\n        }\n    \n    async def validate_translation(\n        self,\n        source_text: str,\n        translated_text: str,\n        source_language: str,\n        target_language: str\n    ) -> Dict[str, Any]:\n        \"\"\"Validate translation quality\"\"\"\n        \n        issues = []\n        warnings = []\n        \n        # Length variance check\n        length_ratio = len(translated_text) / len(source_text)\n        if length_ratio > (1 + self.quality_rules['length_variance']) or \\\n           length_ratio < (1 - self.quality_rules['length_variance']):\n            warnings.append({\n                'type': 'length_variance',\n                'message': f'Translation length varies by {abs(1-length_ratio)*100:.1f}%',\n                'severity': 'warning'\n            })\n        \n        # Placeholder consistency\n        source_placeholders = self.extract_placeholders(source_text)\n        target_placeholders = self.extract_placeholders(translated_text)\n        \n        if source_placeholders != target_placeholders:\n            issues.append({\n                'type': 'placeholder_mismatch',\n                'message': 'Placeholders do not match between source and translation',\n                'source_placeholders': source_placeholders,\n                'target_placeholders': target_placeholders,\n                'severity': 'error'\n            })\n        \n        # HTML tag consistency\n        source_tags = self.extract_html_tags(source_text)\n        target_tags = self.extract_html_tags(translated_text)\n        \n        if source_tags != target_tags:\n            issues.append({\n                'type': 'html_tag_mismatch',\n                'message': 'HTML tags do not match between source and translation',\n                'severity': 'error'\n            })\n        \n        # Language-specific checks\n        if target_language == 'de':\n            issues.extend(self.check_german_specific_rules(translated_text))\n        \n        return {\n            'is_valid': len(issues) == 0,\n            'quality_score': self.calculate_quality_score(issues, warnings),\n            'issues': issues,\n            'warnings': warnings\n        }\n    \n    def check_german_specific_rules(self, text: str) -> List[Dict]:\n        \"\"\"Check German-specific translation rules\"\"\"\n        issues = []\n        \n        # Check for proper capitalization of nouns\n        # This is a simplified check - real implementation would use NLP\n        words = text.split()\n        for i, word in enumerate(words):\n            if i > 0 and word.lower() in self.german_nouns and not word[0].isupper():\n                issues.append({\n                    'type': 'german_capitalization',\n                    'message': f'German noun \"{word}\" should be capitalized',\n                    'position': i,\n                    'severity': 'warning'\n                })\n        \n        return issues\n```\n\n## Performance Considerations\n\n### Caching Strategy\n```python\nfrom functools import wraps\nfrom typing import Dict, Any, Optional\nimport json\nimport hashlib\n\nclass MultilingualCacheManager:\n    def __init__(self, redis_client):\n        self.redis = redis_client\n        self.default_ttl = 3600  # 1 hour\n    \n    def cache_multilingual_content(\n        self, \n        ttl: int = None\n    ) -> callable:\n        \"\"\"Decorator for caching multilingual content\"\"\"\n        def decorator(func):\n            @wraps(func)\n            async def wrapper(*args, **kwargs):\n                # Create cache key including language parameter\n                cache_key = self.generate_cache_key(\n                    func.__name__, \n                    args, \n                    kwargs\n                )\n                \n                # Try to get from cache\n                cached_result = await self.redis.get(cache_key)\n                if cached_result:\n                    return json.loads(cached_result)\n                \n                # Execute function and cache result\n                result = await func(*args, **kwargs)\n                \n                await self.redis.setex(\n                    cache_key,\n                    ttl or self.default_ttl,\n                    json.dumps(result, default=str)\n                )\n                \n                return result\n            return wrapper\n        return decorator\n    \n    def generate_cache_key(self, func_name: str, args: tuple, kwargs: dict) -> str:\n        \"\"\"Generate cache key including language context\"\"\"\n        # Include language in cache key\n        language = kwargs.get('language', 'en')\n        \n        # Create deterministic hash of parameters\n        cache_data = {\n            'function': func_name,\n            'language': language,\n            'args': args,\n            'kwargs': {k: v for k, v in kwargs.items() if k != 'db'}  # Exclude DB session\n        }\n        \n        cache_string = json.dumps(cache_data, sort_keys=True, default=str)\n        cache_hash = hashlib.md5(cache_string.encode()).hexdigest()\n        \n        return f\"ml_content:{language}:{func_name}:{cache_hash}\"\n    \n    async def invalidate_multilingual_cache(self, pattern: str) -> int:\n        \"\"\"Invalidate cache entries matching pattern\"\"\"\n        keys = await self.redis.keys(f\"ml_content:*:{pattern}:*\")\n        if keys:\n            return await self.redis.delete(*keys)\n        return 0\n```\n\n### Database Optimization\n```sql\n-- Optimized query for multilingual content with language fallback\nCREATE OR REPLACE FUNCTION get_localized_content(\n    content_table TEXT,\n    content_id UUID,\n    preferred_language TEXT DEFAULT 'en'\n) RETURNS JSONB\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    result JSONB;\n    query_text TEXT;\nBEGIN\n    -- Build dynamic query\n    query_text := format('\n        SELECT jsonb_build_object(\n            ''id'', id,\n            ''title'', COALESCE(\n                NULLIF(title->>%L, ''''),\n                title->>''en'',\n                ''No title''\n            ),\n            ''content'', COALESCE(\n                NULLIF(content->>%L, ''''),\n                content->>''en'',\n                ''''\n            ),\n            ''language'', CASE\n                WHEN title->>%L IS NOT NULL AND title->>%L != '''' THEN %L\n                ELSE ''en''\n            END\n        )\n        FROM %I\n        WHERE id = %L\n    ', \n        preferred_language, preferred_language, \n        preferred_language, preferred_language, preferred_language,\n        content_table, content_id\n    );\n    \n    EXECUTE query_text INTO result;\n    \n    RETURN result;\nEND\n$$;\n\n-- Usage example\n-- SELECT get_localized_content('pages', 'uuid-here', 'de');\n```\n\n## Success Metrics & KPIs\n\n### Multilingual Adoption Metrics\n- **Language Distribution**: Percentage of users by language preference\n- **Content Coverage**: Percentage of content available in German\n- **Translation Quality**: Average quality scores for AI vs. manual translations\n- **User Language Switching**: Frequency of language changes per session\n- **Geographic Usage**: German content usage by country/region\n- **Conversion Rates**: Comparison of conversion rates between languages\n- **Content Engagement**: Time spent with German vs. English content\n- **Search Performance**: SEO ranking improvements for German keywords\n\n### Technical Performance Metrics\n- **Page Load Times**: Performance comparison between languages\n- **Cache Hit Rates**: Efficiency of multilingual content caching\n- **Translation API Usage**: Cost and performance of AI translation services\n- **Database Query Performance**: Multilingual query optimization effectiveness\n- **Error Rates**: Translation-related errors and fallback usage\n- **Memory Usage**: Additional memory overhead for multilingual support\n- **CDN Performance**: Content delivery performance by geographic region\n\n### Content Management Metrics\n- **Translation Turnaround Time**: Time from content creation to translation\n- **Translation Coverage**: Percentage of new content translated within SLA\n- **Content Synchronization**: Delays between English and German content updates\n- **Translation Accuracy**: Quality scores and revision rates\n- **Translator Productivity**: Translation volume per translator per day\n- **AI Translation Usage**: Percentage of content using AI vs. manual translation\n- **Content Freshness**: Age of translations compared to source content\n\nThis comprehensive multilingual specification ensures that Magnetiq v2 provides a world-class international user experience while maintaining technical excellence and operational efficiency across all supported languages."}]